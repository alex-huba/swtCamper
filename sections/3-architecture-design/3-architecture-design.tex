\section{Architecture \& Design}
\label{sec:architecture_design}

\emph{\textbf{Approximate weighing on mark:} 20\%}							\\
\emph{\textbf{Approximate expected report length:} 5--8 pages of text}

\emph{Describe and justify both the architecture and the design of your software. Illustrate its architecture and design using appropriate UML diagrams. Motivate its architecture and design in the light of design principles and possible alternatives. Also highlight and justify any use of architectural patterns and design patterns. Pay special attention to detailing your database schema, and justify all design decisions taken.}

\paragraph{Primary textual contributors.}
\mbox{}\\\emph{Thomas Kretschmann}

\subparagraph{General}
The implementation of ARACOM Snacks is based on a seperate implementation of front- and backend, connected through a RESTful API. 
The frontend is implemented using  the webapplication framework Angular, the backend is based on Springboot and the database is managed by MariaDB. The connection between backend and database is realised using the ORM framework Hibernate.

\subparagraph{Frontend}
In the frontend, the starting point is the main.ts file, as is usual for web frameworks such as Angular. This is dynamically injected into the \textit{index.html} file and gets the contents of the \textit{app.module.ts} file itself, in which all components and modules of the application are collected and listed. The first 'real' component of the application is \textit{app.component}. A router was implemented from here, which renders a different component depending on the current URL. In our case, these 'main components' are the landing page, which simply contains the links for the other three routes, the food overview, the teakitchen overview and an overview for various statistics. On each of these sites the same navigation bar is rendered on top, which includes links to each route, plus, a button that lets the user log in via \textit{login.service.ts} by authentification via the backend and logging in via \textit{GitLab Auth}. The communication with the backend happens via JavaScript DTOs (more about these in the backend section).

Unlike in other projects, the components were not all structured on one level, only the four main components already mentioned, and the rest in their folders - depending on where they are needed in the application. In this way, other child components were implemented aswell, so that a relatively deep and not particularly wide folder structure was created. This approach worked very well for the most part, since the same components are rarely reused in the application - especially not in other main components - and the structure is way cleaner. This procedure was broken with \textit{tea-kitchen-overview}, for example, because this component renders \textit{tea-kitchen-details}, but the latter is still not \textbf{in} \textit{tea-kitchen-overview}, but next to it. Since \textit{tea-kitchen} itself only renders the navigation bar and \textit{tea-kitchen-overview}, the complete \textit{tea-kitchen-overview} component could have been easily implemented in \textit{tea-kitchen}. \\
Same goes for \textit{product-info} that is rendered by \textit{overview-item}, but does not lie inside its folder, but next to it on the same level.

Other things that could have been implemented better are on the one hand the constant use of \textit{ng-bootstrap}, and on the other hand the determination of the role of the user via \textit{user.service.ts}. Usually, the services in the application were used in such a way that they can be used as effectively as possible. For example, the list of tea kitchens is only fetched once from the backend (\texttt{GET}) in \textit{tea-kitchen-overview} and then passed on to the child components instead of making new requests. In the case of the user service, however, this was not so easy to accomplish, since the role is already required for the navigation bar and therefore has to be determined \textbf{before} the router. Unfortunately, the developers did not manage to pass on the determined data across the router and distribute them via the application, since the router is a standard component that has already been implemented and does not allow any custom properties. Although it \textbf{is} possible by using \href{https://stackoverflow.com/questions/41451375/passing-data-into-router-outlet-child-components}{a own service}, the developers did not manage to implement it since \textit{Observables} were still a too unknown field at this point; instead, the user service was implemented in several places in the application and \texttt{GET}s the information several times, but nevertheless in such a way that the component that contains it can pass on the information as widely as possible. \\
Regarding the more constant use of \textit{ng-bootstrap}, it can be said that optically it makes no difference whether 'normal' \textit{Bootstrap} is used via the classes or \textit{ng-bootstrap}, but the latter provides accessibility for some components that the normal in Angular can not offer. This was particularly noticeable when using the modals, which we could not close programmatically without \textit{ng-bootstrap} other than imitating a 'click' on the pre-implemented button. With \textit{ng-bootstrap} it was then possible to address and modify the modal directly using \textbf{NgbModal} and \textbf{NgbActiveModal}. In addition, several modals could be stacked without any problems.

In general, the entire application would probably be more efficient if a so-called \textbf{store}, such as \textit{Ngx-Store}, existed, as is the case in business applications, which then manages the complete state of the app and always makes it available for each component up-to-date. The implementation of such a store is anything but trivial and is recommended for more experienced developers.

\subparagraph{Backend}
The point of intersection between front- and backend is implemented by REST consumers in the controller interfaces. These endpoints receive and send http requests to and from the frontend over the REST API using Data Transfer Objects (DTOs) – simple Java objects holding minimal information, ensuring that only necessary data is transferred.
The data hiding principle is implemented well in DTOs like the \textit{consumptionDTO}, which is not directly tied to an entity but instead holds minimal cross-entity information necessary for the consumption process. Other DTOs hold more information and map all entity attributes, some of which are not of immediate use for the required functionality in the frontend. For instance, while updating a tea kitchen, all data concerning the relevant tea kitchen including unchanged attributes are sent to the backend. While this works well for this project, it could lead to future problems as increasing complexity will result in large data chunks that are transmitted unnecessarily, security concerns will become more relevant and the need for more targeted functionality – possibly according to authentication level – will likely result in necessary refactoring.
The reason for the general approach in this project is that the focus was on reusability of components and functionality, rather than on carefully targeted actions. This was possible for this project for two reasons: first, it had a comparatively small scope and most actions could clearly be assigned to a role and are only triggered in one place in the system, so that complex authentication was not necessary. Second, the transmission of all data for overview screens was necessary in any case - therefore reusage was sensible. 
Nevertheless, future implementations could be enhanced by improving the trade-off between reusability and minimality of DTOs and consequently having a more fine-grained API. This can be achieved by better communication between implementors of front- and backend during the early stages of the project: it is important to analyze which data is necessary for the intended use and reasonable to request from the frontend - ideally also with regard to possible future uses – and agree on the interface before implementation is begun to avoid refactoring during later stages.  

DTOs are received and sent by Controllers, which implement controller interfaces. They map DTOs to entity objects, which represent specific table entries in the relational database provided by MariaDB. Also, they call all services required to implement the request of the REST consumer. Services will take care of basic functionality and updating of entity objects before calling repositories to initiate updates of the database. Repositories provide mapping between entity objects and the database for which they rely on the JPA implementation Hibernate. 
In this project, major core functionalities of the system are implemented by services, as many requests are simple bookkeeping requests such as adding or updating objects.
However, as discussed above, the project could benefit from a more fine-grained implementation of functionality and a stricter adherence to the separations of concerns. For instance, the implementation of more complex methods such as the consume method in \textit{stockItemService} could significantly be improved by separate calls to the \textit{userService} and \textit{stockItemService} in the\textit{ StockItemController}, rather than having all functionality implemented in the \textit{stockItemService}. 
As has already become evident during the last sprint, a better separation of concerns would not only allow for better traceability but also for better modifiability, as single modules could be revised separately. Moreover, if services were more strictly separated and communicated only over the controller, new team members could understand the code more easily, as no unexpected side-effects would occur. To ensure this in future projects, experienced programmers could be asked for their feedback on the system design and the required functionality should be revised more carefully and with a focus on separation of concerns early on.
