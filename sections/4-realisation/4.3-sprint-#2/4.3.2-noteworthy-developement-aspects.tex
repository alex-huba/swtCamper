After a somewhat chaotic sprint 1, we decided to revise our development approach. We identified several issues:

\begin{itemize}
    \item \textbf{Not enough planning:}
    \begin{itemize}
        \item \textbf{Solution:} When creating an issue/task during/after the product backlog meeting (our name for a preliminary sprint planning meeting which was held right after the sprint review meetings by two team members, and during which we went over the meeting notes of the last review and created all foreseeable tasks), think about who would be suited best to work on it. By doing this, the process of allocating tasks to team members during the following sprint planning meeting could be sped up.
    \end{itemize}
    \item \textbf{Difficulties keeping an overview over the current state of the application:}
    \begin{itemize}
        \item \textbf{Solution:} We decided to be stricter in our handling of issues, we made it mandatory to include a due date, a user story/milestone, a brief description if sensible and to assign a team member as soon as the issue is moved from product backlog to sprint backlog. In addition to that, we emphasized that every team member is responsible for updating their issues when necessary and to keep an eye on the overall orderliness of the issues board.
    \end{itemize}
    \item \textbf{Due to insufficient coding experience of most team members, code quality was poor:}
    \begin{itemize}
        \item \textbf{Solution:} We decided to assign two team members to any non-trivial tasks. By using the pair programming technique, we assured that two team members write and think about a part of the application at the same time. To further utilize this technique, we assigned not just any two team members, but, where possible and sensible, team members from different “areas of expertise” (e.g., frontend and backend, or, when writing interfaces, two team members from each “side” of the interface, i.e. one from each part of the application the interface is supposed to “connect”. An example would be). In addition to that, we decided to emphasize the importance of thoroughly reviewing code, either when asked to do so or when handling merge requests. We made sure to never let someone who worked on the branch to be merged handle the merge request, but a third person with “fresh eyes”.
    \end{itemize}
    \item \textbf{Insufficient experience with the technology used (e.g., git, Docker, Spring Boot, working with databases)}
    \begin{itemize}
        \item \textbf{Solution:} We emphasized using the “Manual” page in the GitLab wiki, which was created to gather helpful tips and commands, and even short tutorials on common use cases (e.g., GitLab markdown tags, additions to the docker-compose commands)
    \end{itemize}
\end{itemize}

Artifacts produced in sprint 2 were .fxml files for each view necessary to fulfill our sprint goal (rentingView, loginView, registrationView), as well as navigationView.fxml, and the respective ViewController classes. In addition, we updated our prototype to now include the sprint goal functionalities and feedback we received in the last sprint review meeting from the customer: A new navigation sidebar so users can quickly and always access all subsections of the application, with icons instead of written out menu items, in order to keep the sidebar slim and to make (at least the menu) language independent. The sidebar can be expanded to show the actual menu item names. The layout was changed to a widescreen format, a FAQ section was added, as well as a deal history section to record current and previous bookings, and a screen demonstrating the functionality to add custom vehicle features when creating an offer.

As we added the actual offer attributes to the offer class, we realized that the lifecycle of offers is more complex than we thought, so an offer lifecycle diagram was created. During creation of the diagram, we discovered several questions we hadn’t asked ourselves before, e.g. what happens upon deletion (whether the offer is actually deleted depends on its active/inactive status), or how we should handle the availability of offered vehicles (instead of a simple Boolean (which in retrospect didn’t make sense as an offer, as we implemented it, cannot be available or unavailable as a whole, only for periods of time) we started to think about the concept of a booking object).

Obstacles we encountered in this sprint were in part of organizational nature, i.e., team members, due to personal reasons, not being available as much as planned. Because of this the pair programming approach was abandoned for the task “Implement search functionality”, which we compensated for by assigning one of the more experienced team members. Difficulties with git kept a team member from working on the unit tests for the OfferService, which was then postponed until a later, more convenient date. Despite being aware of the importance and usefulness of regular testing during, not after the coding process, we had to weigh all options and decided to prioritize the advance of the application. A technical issue regarding accessing Optional-objects coming from the repository (stemming from an insufficient understanding of optionals) was solved with the help of Ms. Jacob during the mid sprint meeting. An JPA-related error multiple team members encountered was resolved by the docker-compose down -v command, which was subsequently used many times, as old database entries often led to errors when our entity objects changed.
